---
title: "Programming concepts"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
# output: rmarkdown::html_vignette
# vignette: >
#  %\VignetteIndexEntry{Class-8}
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteEncoding{UTF-8}
---

```{r setup, include = F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "left"
)
library(tidyverse)
library(ggrepel)
library(pbda)
library(cowplot)
```

## Functions

### When should you write a function?
It's important to avoid duplication in your code. One way to limit duplication is by converting code that has to be run multiple times into a function. You should write a function if you've repeated a block of code more than once or twice.

Functions have several advantages:

1. They make your code easier to read
2. They reduce the chance of mistakes from copying and pasting code
3. It's easier to adapt your code for different requirements since you only have to modify one place
```{r}
# An example: you want to rescale a numeric vector so all values are between 0 and 1
a <- rnorm(n = 10)
a

rng <- range(a)
(a - rng[1]) / (rng[2] - rng[1])

# What if we want to repeat this on other vectors?
b <- rnorm(n = 10)
b

c <- rnorm(n = 10)
c

rng <- range(b)
new_b <- (b - rng[1]) / (rng[2] - rng[1])

rng <- range(c)
new_c <- (c - rng[1]) / (rng[2] - rng[1])
```

<br>

<br>

### Function structure
There are three main steps for writing functions:

1. Pick a name
2. List the arguments
3. Add code to the body
```{r}
# A simple function to average two numbers
calc_mean <- function(x, y) {
  (x + y) / 2
}

calc_mean <- function(x, y) (x + y) / 2

calc_mean(2, 5)
```

<br>

*Write a function to rescale a numeric vector*
```{r}
rescale_nums <- function(x) {
  x_rng <- range(x)
  (x - x_rng[1]) / (x_rng[2] - x_rng[1])
}

rescale_nums(b)
rescale_nums(c)
```

<br>

<br>

### The function execution environment
- When running a function an execution environment is created, which is separate from the global environment
- The execution environment consists of objects created by the function
- The execution environment follows the "fresh start" principle
- When R searches for an object referenced by a function, the execution environment takes precedence

<br>

*Can objects present in the global environment be referenced from within a function?*
```{r}
# Earlier we saved a numeric vector "a"
a

sum_nums <- function(x) {
  x + a
}

sum_nums(10)
```

<br>

*Can code executed within a function modify an object present in the global environment?*
```{r}
sum_nums <- function(x) {
  a <- x + a
  a
}

# When we run sum_nums(), will this overwrite our original vector?
sum_nums(10)

a
```

<br>

<br>

### A more relevant example
Lets create a scatter plot comparing growth rate vs expression for the gene YDL104C. We can use `facet_wrap()` to create a separate plot for each nutrient.
```{r, fig.width = 6, fig.height = 4.5}
brauer_gene_exp %>%
  filter(systematic_name == "YDL104C") %>%           # Filter for gene of interest
  ggplot(aes(rate, expression, color = nutrient)) +  # Create scatter plot
  geom_point(size = 2) +
  geom_smooth(method = "lm", se = F, size = 0.5) +   # Add best fit line
  facet_wrap(~ nutrient) +                           # Create separate plot for each nutrient
  theme_cowplot() +
  theme(legend.position = "none")
```

<br>

What if you want to create this plot for multiple genes? *Write a function the takes a data.frame and systematic_name as inputs and creates scatter plots for each nutrient*
```{r, fig.width = 6, fig.height = 4.5}
plot_growth <- function(input, sys_name) {
  input %>%
    filter(systematic_name == sys_name) %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", se = F, size = 0.5) +
    facet_wrap(~ nutrient) +
    theme_cowplot() +
    theme(legend.position = "none")
}

plot_growth(input = brauer_gene_exp, sys_name = "YDL104C")
```

<br>

*Modify our plotting function to add the gene name as the plot title and the molecular function (MF) as a subtitle*
```{r, fig.width = 6, fig.height = 4.5}
plot_growth <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", se = F, size = 0.5) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme_cowplot() +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_growth("YDL104C")
```

<br>

<br>

### Conditional statements
`if` statements allow you to execute code depending on defined conditions.
```
if (condition) {
  code executed when condition is TRUE
  
} else {
  code executed when condition is FALSE
}
```

R has a set of operators that can be used to write conditional statements

Operator | Description
:-------:|:-----------
<        | less than
<=       | less or equal
\>       | greater than
\>=      | greater or equal
==       | equal
!=       | not equal
!x       | not x
x \|\| y | x or y
x && y   | x and y
x %in% y | x is present in y

<br>

*Add an `if` statement to our plotting function to account for a missing gene name*
```{r, fig.width = 6, fig.height = 4.5}
plot_growth <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", se = F, size = 0.5) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme_cowplot() +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_growth("YNL095C")
```

<br>

<br>

### Multiple conditions
```{r, eval = F}
if (condition_1) {
  executed when condition_1 is TRUE
  
} else if (condition_2) {
  executed when condition_2 if TRUE
  
} else {
  executed when condition_1 and condition_2 are FALSE
}


if (condition_1 && condition_2) {
  executed when condition_1 and condition_2 are TRUE
  
} else {
  executed when condition_1 or condition_2 are FALSE
}


if (condition_1 || condition_2) {
  executed when condition_1 or condition_2 are TRUE
  
} else {
  executed when condition_1 and condition_2 are FALSE
}
```

<br>

<br>

### Checking inputs
When writing functions it can be useful to check input values to make sure they are valid. Lets modify our plotting function to check that `sys_name` is a string.
```{r, fig.width = 6, fig.height = 4.5}
plot_growth <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", se = F, size = 0.5) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme_cowplot() +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_growth("YDL104C")
```

<br>

*Modify our plotting function to check that `sys_name` is present in the input. Hint: use the `%in%` operator*
```{r, fig.width = 6, fig.height = 4.5}
plot_growth <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  if (!sys_name %in% input$systematic_name) {
    stop("sys_name not found in input data!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", se = F, size = 0.5) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme_cowplot() +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_growth("YDL104C")
```

<br>

<br>

### Passing arguments with dots (...)
dots allow a function to take an arbitrary number of arguments, which can then be passed to other functions. Lets first try this using our simple `rescale_nums()` function. 
```{r}
rescale_nums <- function(x, ...) {
  x_rng <- range(x, ...)
  (x - x_rng[1]) / (x_rng[2] - x_rng[1])
}

rescale_nums(a)

a[1] <- NA

rescale_nums(a, na.rm = T)
```

<br>

*Modify our plotting function to pass arguments through dots to ggplot*
```{r, fig.width = 6, fig.height = 4.5}
plot_growth <- function(input, sys_name, ...) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  if (!sys_name %in% input$systematic_name) {
    stop("sys_name not found in input data!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(...) +
    geom_smooth(method = "lm", se = F, size = 0.5) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme_cowplot() +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_growth(
    sys_name = "YDL104C",
    size  = 3,
    shape = 5,
    alpha = 0.5
  )
```

<br>

<br>

## Iteration

### `for` loops
As discussed in the previous section, it is important to limit duplication in your code. One way to do this is by writing functions, another way is through iteration. `for` loops allow you to run the same code block repeatedly without copying and pasting.
```{r}
for (i in 1:5) {
  print(i)
}

for (i in 1:5) {
  print(2 * i)
}

# Maybe instead of printing, we want to save these new values
out <- vector("numeric", 5)

for (i in 1:5) {
  out[i] <- 2 * i
}

out

# A slightly more complicated example
out <- vector("list", 5)

out[[1]] <- rnorm(n = 10, mean = 1)
out[[2]] <- rnorm(n = 10, mean = 50)
out[[3]] <- rnorm(n = 10, mean = 20)
out[[4]] <- rnorm(n = 10, mean = 5)
out[[5]] <- rnorm(n = 10, mean = 70)

# Use a for loop to reduce code duplication
means <- c(1, 50, 20, 5, 70)
out <- vector("list", length(means))

for (i in seq_along(means)) {
  out[[i]] <- rnorm(n = 10, mean = means[[i]])
}

out
```

<br>

<br>

### A more relevant example
```{r, fig.width = 10, fig.height = 8}
growth_plots <- vector("list", 4)

growth_plots[[1]] <- brauer_gene_exp %>%
  plot_growth(
    sys_name = "YDL104C",
    size  = 3,
    shape = 5
  )

growth_plots[[2]] <- brauer_gene_exp %>%
  plot_growth(
    sys_name = "YOR069W",
    size  = 3,
    shape = 5
  )

growth_plots[[3]] <- brauer_gene_exp %>%
  plot_growth(
    sys_name = "YLR115W",
    size  = 3,
    shape = 5
  )

growth_plots[[4]] <- brauer_gene_exp %>%
  plot_growth(
    sys_name = "YPR036W",
    size  = 3,
    shape = 5
  )

plot_grid(plotlist = growth_plots)
```

<br>

*Re-write the code from above using a for loop to generate our growth rate figure*
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
growth_plots <- vector("list", 4)

for (i in seq_along(growth_plots)) {
  growth_plots[[i]] <- brauer_gene_exp %>%
    plot_growth(
      sys_name = genes[i],
      size  = 3,
      shape = 5
    )
}

plot_grid(plotlist = growth_plots)
```

<br>

<br>

### Introduction to `purrr::map`
`for` loops are a powerful tool to reduce code duplication, however your code can be further simplified using the `map()` functions provided in the purrr package. These `map()` functions essentially run `for (i in seq_along())` behind the scenes so you don't have to explicitly type this code out.

There is a function for each type of output:

- `map()` makes a list
- `map_lgl()` makes a logical vector
- `map_int()` makes an integer vector
- `map_dbl()` makes a double vector
- `map_chr()` makes a character vector

Each `map()` function requires two inputs: `map(.x, .f, ...)`

- `.x` is a list or atomic vector
- `.f` is a function or formula
```{r}
# We previously used a for loop to create vectors with different means
means <- c(1, 50, 20, 5, 70)
out <- vector("list", length(means))

for (i in seq_along(means)) {
  out[[i]] <- rnorm(n = 10, mean = means[[i]])
}

# Using map() we can further simplify this code
out <- map(means, function(x) rnorm(n = 10, mean = x))

out <- map(means, ~ rnorm(n = 10, mean = .x))

out <- map(means, rnorm, n = 10)

out
```

<br>

*Re-write the code from above using `map()` to generate our growth rate figure*
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

growth_plots <- map(
  .x    = genes,
  .f    = plot_growth,
  input = brauer_gene_exp
)

# growth_plots <- map(genes, ~ plot_growth(input = brauer_gene_exp, sys_name = .x))

plot_grid(plotlist = growth_plots)
```

<br>

<br>

### Mapping over multiple arguments
If you have two vectors containing values that you want to pass to a function this can be accomplished with `map2`.
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
shapes <- c(1, 2, 3, 4)

growth_plots <- map2(genes, shapes, ~ {
  brauer_gene_exp %>%
    plot_growth(
      sys_name = .x,
      size     = 3,
      shape    = .y
    )
})

plot_grid(plotlist = growth_plots)
```

<br>

`pmap` can be used to map over any number of arguments.
```{r, fig.width = 10, fig.height = 8}
plot_args <- list(
  sys_name = c("YDL104C", "YOR069W", "YLR115W", "YPR036W"),
  size = c(2, 3, 4, 5),
  shape = c(1, 2, 3, 4)
)

growth_plots <- pmap(plot_args, plot_growth, brauer_gene_exp)

plot_grid(plotlist = growth_plots)
```

<br>

<br>

## Factors

### What are factors?
Factors are useful when you want to modify how categorical data is displayed. To manipulate factors tidyverse provides the forcats package.
```{r}
# Imagine we have a character vector containing a few months
x <- c("Dec", "Apr", "Jan", "Mar")
x

# Sorting this vector will arrange the months in alphabetical order, which isn't useful
sort(x)

# To sort our months based on their order in the year, we can convert to a factor
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)

y <- factor(x, levels = month_levels)
y

sort(y)
```

<br>

<br>

### Using forcats with ggplot2
The forcats package has several key functions:

- `fct_relevel` to manually set factor order
- `fct_reorder` to reorder by another variable
- `fct_inorder` to order by appearance
- `fct_infreq` to order by the frequency of values
- `fct_lump` to collapse the least/most frequency values into "Other"

<br>

Lets try to use some of these functions to modify our growth rate plots.
```{r, fig.width = 6, fig.height = 4.5}
# fct_relevel
nutrient_levels <- c(
  "Phosphate", "Sulfate", "Uracil",
  "Ammonia",   "Glucose", "Leucine"
)

gg_data <- brauer_gene_exp %>%
  filter(systematic_name == "YOL066C")

gg_data %>%
  mutate(nutrient = fct_relevel(nutrient, nutrient_levels)) %>%
  
  ggplot(aes(rate, expression, color = nutrient)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = F, size = 0.5) +
  facet_wrap(~ nutrient) +
  theme_cowplot() +
  theme(legend.position = "none")

# fct_reorder
gg_data %>%
  mutate(nutrient = fct_reorder(nutrient, expression, max)) %>%
  
  ggplot(aes(rate, expression, color = nutrient)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = F, size = 0.5) +
  facet_wrap(~ nutrient) +
  theme_cowplot() +
  theme(legend.position = "none")

# fct_inorder
gg_data %>%
  mutate(nutrient = fct_inorder(nutrient)) %>%
  
  ggplot(aes(rate, expression, color = nutrient)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = F, size = 0.5) +
  facet_wrap(~ nutrient) +
  theme_cowplot() +
  theme(legend.position = "none")
```

<br>

Lets try another example using `fct_lump()` and `fct_infreq()`.
```{r, fig.width = 5, fig.height = 4.5}
gg_data <- brauer_gene_exp %>%
  select(MF, systematic_name) %>%
  unique()

# fct_lump
gg_data %>%
  mutate(MF = fct_lump(MF, n = 10)) %>%
  
  ggplot(aes(x = "MF", fill = MF)) +
  geom_bar(position = "fill") +
  theme_cowplot()

# fct_infreq
gg_data %>%
  mutate(
    MF = fct_lump(MF, n = 10),
    MF = fct_infreq(MF)
  ) %>%
  
  ggplot(aes(x = "MF", fill = MF)) +
  geom_bar(position = "fill") +
  theme_cowplot()
```

<br>

*ADD SOME EXERCISES*

```{r "EXTRAs", include = F}
# ggplot(aes(rate, expression, color = nutrient)) +
#   geom_point() +
#   geom_smooth(method = "lm", se = F, size = 0.5) +
#   theme_cowplot() +
#   theme(legend.position = "none") +
#   facet_wrap(~ nutrient)
# MF = fct_infreq(MF)
# MF = fct_reorder(MF, systematic_name, n_distinct)
# x <- brauer_gene_exp %>%
#   group_by(systematic_name) %>%
#   nest(keys = c(rate, expression)) %>%
#   mutate(slope = map(keys, ~ {
#     mod <- lm(.x$expression ~ .x$rate)
#     mod$coefficients[[2]]
#   })) %>%
#   unnest(cols = c(keys, slope))
# x %>%
#   filter(systematic_name == "YOL066C") %>%
#   ggplot(aes(rate, expression, color = nutrient)) +
#   geom_point() +
#   geom_smooth(method = "lm", se = F, size = 0.5) +
#   facet_wrap(~ fct_reorder(nutrient, slope, mean)) +
#   theme_cowplot() +
#   theme(legend.position = "none")
```








