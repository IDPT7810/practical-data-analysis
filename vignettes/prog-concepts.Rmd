---
title: "Programming concepts"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_float: true
    toc_depth: 3
---

```{r setup, include = F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "left"
)
library(pbda)
library(tidyverse)
library(cowplot)
```

## Functions

### What is a function?
As an analyst you will eventually find yourself in the position of wanting to reuse a block of code. There are two general ways to do this:

1. copy-and-paste
2. write a function

A function is essentially a block of code that you've given a name and saved for later. Functions have several advantages:

* They make your code easier to read
* They reduce the chance of mistakes from repeated copying and pasting
* They make it easier to adapt your code for different requirements

Further reading

* [R for Data Science]("https://r4ds.had.co.nz/") by Garrett Grolemund and Hadley Wickham
* [Advanced R]("https://adv-r.hadley.nz/") by Hadley Wickham
```{r}
# An example: you want to rescale a numeric vector so all values are between 0 and 1
a <- rnorm(n = 10)
a

rng <- range(a)
(a - rng[1]) / (rng[2] - rng[1])

# What if we want to repeat this on other vectors?
# One way is to copy and paste
b <- rnorm(n = 10)
c <- rnorm(n = 10)

rng <- range(b)
new_b <- (b - rng[1]) / (rng[2] - rng[1])

rng <- range(c)
new_c <- (c - rng[1]) / (rng[2] - rng[1])

# A better way is to write a function...
```

<br>

<br>

### Function structure
There are three general steps for writing functions:

1. Pick a name
2. Identify the inputs
3. Add code to the body
```{r, eval = F}
# Lets write a function to rescale a numeric vector
rescale_vec <- function(x) {
  
  rng <- range(x)
  (x - rng[1]) / (rng[2] - rng[1])

}

rescale_vec(b)
rescale_vec(c)
```

<br>

*Write functions for the following bits of code*
```{r, eval = F}
# function 1
x / sum(x)

# function 2
(x + y) / z

# function 3
sqrt(sum((x - mean(x))^2) / (length(x) - 1))
```

```{r, echo = F}
calc_sd <- function(x) {
  sqrt(sum((x - mean(x))^2) / (length(x) - 1))
}

calc_sd <- function(x) {
  l <- length(x) - 1
  m <- mean(x)
  v <- sum((x - m)^2) / l
  sqrt(v)
}
```

<br>

<br>

### The function execution environment
- When running a function an execution environment is created, which is separate from the global environment
- The execution environment contains objects created within the function
- The execution environment follows the "fresh start" principle
- When R searches for an object referenced by a function, the execution environment takes precedence

<br>

*Can objects present in the global environment be referenced from within a function?*
```{r}
# Earlier we saved a numeric vector "a"
a

sum_nums <- function(x) {
  x + a
}

# Yes!
sum_nums(10)
```

<br>

*Can code executed within a function modify an object present in the global environment?*
```{r}
sum_nums <- function(x) {
  a <- x + a
}

# When we run sum_nums(), will this overwrite our original vector?
sum_nums(10)

# No! (not when using the '<-' assignment operator)
a
```

<br>

<br>

### A more relevant example
*Using the Brauer data lets create a scatter plot comparing growth rate vs expression for the gene YDL104C. Use `facet_wrap()` to create a separate plot for each nutrient.*
```{r, fig.width = 6, fig.height = 4.5, echo = F}
gg_data <- brauer_gene_exp %>%
  filter(systematic_name == "YDL104C")               # Filter for gene of interest

gg_data %>%
  ggplot(aes(rate, expression, color = nutrient)) +  # Create scatter plot
  geom_point(size = 2) +
  facet_wrap(~ nutrient) +                           # Create separate plot for each nutrient
  theme(legend.position = "none")
```

<br>

What if you want to create this plot for other genes? *Write a function the takes a data.frame and systematic_name as inputs and creates scatter plots for each nutrient*
```{r, eval = F}
# Fill in the function body
# You can include default values for your arguments
plot_expr <- function(input, sys_name = "YNL049C") {
  
  ????
  
}
```

```{r, echo = F}
plot_expr <- function(input, sys_name = "YNL049C") {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, fig.width = 6, fig.height = 4.5}
p <- plot_expr(
  input = brauer_gene_exp, 
  sys_name = "YDL104C"
)

# You can also use the %>% pipe with your custom functions
p <- brauer_gene_exp %>%
  plot_expr(sys_name = "YDL104C")

p
```

<br>

*Modify our plotting function to add the gene name as the plot title and the molecular function (MF) as a subtitle*
```{r, echo = F}
plot_expr <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    ggtitle(plot_title) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, fig.width = 6, fig.height = 4.5}
brauer_gene_exp %>%
  plot_expr("YDL104C")
```

<br>

<br>

### Conditional statements
`if` statements allow you to execute code depending on defined conditions.
```{r, eval = F}
if (condition) {
  code executed when condition is TRUE
  
} else {
  code executed when condition is FALSE
}
```

R has a set of operators that can be used to write conditional statements

Operator | Description
:-------:|:-----------
<        | less than
<=       | less or equal
\>       | greater than
\>=      | greater or equal
==       | equal
!=       | not equal
!x       | not x
x \|\| y | x or y
x && y   | x and y
x %in% y | x is present in y

<br>

*Add an `if` statement to our plotting function to account for a missing gene name*
```{r, eval = F}
plot_expr <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  ????
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, echo = F}
plot_expr <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, fig.width = 6, fig.height = 4.5}
brauer_gene_exp %>%
  plot_expr("YNL095C")
```

<br>

Conditional statements can be linked together
```{r, eval = F}
# Using 'else if'
if (condition_1) {
  executed when condition_1 is TRUE
  
} else if (condition_2) {
  executed when condition_1 is FALSE and condition_2 is TRUE
  
} else {
  executed when condition_1 and condition_2 are FALSE
}

# The 'and' operator
if (condition_1 && condition_2) {
  executed when condition_1 and condition_2 are TRUE
  
} else {
  executed when condition_1 or condition_2 are FALSE
}

# The 'or' operator
if (condition_1 || condition_2) {
  executed when condition_1 or condition_2 are TRUE
  
} else {
  executed when condition_1 and condition_2 are FALSE
}
```

<br>

<br>

### Checking inputs
When writing functions it can be useful to check input values to make sure they are valid. Lets modify our plotting function to check that `sys_name` is a string.

- `is.character()`
- `is.numeric()`
- `is.logical()`
- `is.factor()`

```{r, fig.width = 6, fig.height = 4.5}
plot_expr <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_expr("YDL104C")
```

<br>

*Modify our plotting function to check that `sys_name` is present in the input. Hint: try the `%in%` operator*
```{r, eval = F}
plot_expr <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  if ( ???? ) {
    stop( ???? )
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, echo = F}
plot_expr <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  if (!sys_name %in% input$systematic_name) {
    stop("sys_name not found in input data!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

<br>

<br>

### Passing arguments with the ellipsis (...)
The ellipsis allows a function to take an arbitrary number of arguments, which can then be passed to an inner function. This is nice when you have an inner function that has a lot of useful arguments. Lets first try this with our simple `rescale_vec()` function. 
```{r}
rescale_vec <- function(x, ...) {
  x_rng <- range(x, ...)
  (x - x_rng[1]) / (x_rng[2] - x_rng[1])
}

rescale_vec(a)

a[1] <- NA

rescale_vec(a, na.rm = T)
```

<br>

*Modify our plotting function so the user can change the point size, shape, and alpha*
```{r, fig.width = 6, fig.height = 4.5}
# A cumbersome way
plot_expr <- function(input, sys_name, pt_size = 2, pt_shape = 1, pt_alpha = 1) {
  input %>%
    filter(systematic_name == sys_name) %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = pt_size, shape = pt_shape, alpha = pt_alpha) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

# With the ellipsis
plot_expr <- function(input, sys_name, ...) {
  input %>%
    filter(systematic_name == sys_name) %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(...) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

# Now we can easily change the point size and shape
plot_expr(
  input = brauer_gene_exp,
  sys_name = "YDL104C",
  size = 5,
  shape = 2,
  alpha = 0.5
)
```

<br>

<br>

### Saving your functions for later
A good way to save commonly used functions is to keep them in a separate R script. You can load your functions using the `source()` command.
```{r, eval = F}
source("path/to/my_functions.R")
```

<br>

<br>

## Iteration

### `for` loops
As discussed in the previous section, you should try to limit duplication in your code. One way to do this is by writing functions, another way is through iteration. `for` loops allow you to run the same code block repeatedly without copying and pasting.
```{r}
# When writing a for loop, think about the output, sequence, and body
out <- vector("numeric", 5)  # 1. output

for (i in 1:length(out)) {   # 2. sequence
  
  out[i] <- 2 * i            # 3. body
  
}
```

```{r}
# Lets use rnorm() to create 5 vectors with different values for 'mean'
# One way to do this is by copying and pasting
out <- vector("list", 5)

out[[1]] <- rnorm(n = 10, mean = 1)
out[[2]] <- rnorm(n = 10, mean = 50)
out[[3]] <- rnorm(n = 10, mean = 20)
out[[4]] <- rnorm(n = 10, mean = 5)
out[[5]] <- rnorm(n = 10, mean = 70)

# Use a for loop to reduce code duplication
# seq_along() is a safer way of writing 1:length(x)
vals <- c(1, 50, 20, 5, 70)

out <- vector("list", length(vals))          # 1. output

for (i in seq_along(vals)) {                 # 2. sequence
  
  out[[i]] <- rnorm(n = 10, mean = vals[i])  # 3. body
  
}
```

<br>

*Write a `for` loop to create 3 vectors of different lengths*
```{r, echo = F}
lens <- c(5, 10, 2)

out <- vector("list", length(lens))  # 1. output

for (i in seq_along(lens)) {         # 2. sequence
  
  out[[i]] <- rnorm(n = lens[i])     # 3. body
  
}

out
```

<br>

<br>

### Lets try this with the Brauer data
```{r, fig.width = 10, fig.height = 8}
# We want to create a supplemental figure showing the growth rate vs expression for four genes
plot_expr <- function(input, sys_name, ...) {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(...) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

expr_plots <- vector("list", 4)

expr_plots[[1]] <- brauer_gene_exp %>%
  plot_expr(sys_name = "YDL104C")

expr_plots[[2]] <- brauer_gene_exp %>%
  plot_expr(sys_name = "YOR069W")

expr_plots[[3]] <- brauer_gene_exp %>%
  plot_expr(sys_name = "YLR115W")

expr_plots[[4]] <- brauer_gene_exp %>%
  plot_expr(sys_name = "YPR036W")

plot_grid(plotlist = expr_plots)
```

<br>

*Re-write the code from above using a `for` loop to generate our figure*
```{r, eval = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

expr_plots <- vector("list", 4)  # 1. output

for ( ???? ) {                   # 2. sequence
  
                                 # 3. body

}

plot_grid(plotlist = expr_plots)
```

<br>

<br>

### Introduction to `map()`
`for` loops are a powerful tool to reduce code duplication, however your code can be further simplified using the `map()` functions provided in the purrr package. These `map()` functions essentially run `for (i in seq_along(x))` behind the scenes so you don't have to explicitly type this.

There is a function for each type of output:

- `map()` makes a list
- `map_lgl()` makes a logical vector
- `map_int()` makes an integer vector
- `map_dbl()` makes a double vector
- `map_chr()` makes a character vector

Each `map()` function requires two inputs: `map(.x, .f, ...)`

- `.x` is a list or atomic vector
- `.f` is a function or formula
```{r}
# We previously used a for loop to create vectors with different values for mean
vals <- c(1, 50, 20, 5, 70)

out <- vector("list", length(vals))          # 1. output

for (i in seq_along(vals)) {                 # 2. sequence
  
  out[[i]] <- rnorm(n = 10, mean = vals[i])  # 3. body
  
}

# Using map() we can further simplify this code
# .x indicates where each element of the vector should be inserted
out <- map(
  .x = vals,
  .f = ~ rnorm(n = 10, mean = .x)
)

# You can use brackets to include a multi-line code block
out <- map(vals, ~ {
  rnorm(n = 10, mean = .x)
})

# map() allows for very readable code
# Each element of the vector is passed to the first available argument
out <- map(vals, rnorm, n = 10)
```

<br>

*Use `rnorm()` and `map()` to create 3 vectors of different lengths*
```{r, echo = F}
lens <- c(5, 10, 2)

out <- map(lens, ~ rnorm(n = .x))

out <- map(lens, rnorm)

out
```

<br>

*Re-write the code from above using `map()` to generate our growth rate figure*
```{r, eval = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

expr_plots <- map(
  
  ????
  
)

plot_grid(plotlist = expr_plots)
```

```{r, fig.width = 10, fig.height = 8, echo = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

expr_plots <- map(
  .x = genes, 
  .f = plot_expr, 
  input = brauer_gene_exp
)

plot_grid(plotlist = expr_plots)
```

<br>

<br>

### Mapping over multiple arguments
If you have two vectors containing values that you want to pass to a function this can be accomplished with `map2()`.
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
shapes <- c(1, 2, 3, 4)

expr_plots <- map2(genes, shapes, ~ {
  plot_expr(
    input    = brauer_gene_exp,
    sys_name = .x,
    shape    = .y
  )
})

plot_grid(plotlist = expr_plots)
```

<br>

*Use `map2()` to create plots for 4 different genes, each with a different point size*
```{r, eval = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

expr_plots <- map2(
  
  ????
  
)

plot_grid(plotlist = expr_plots)
```

```{r, fig.width = 10, fig.height = 8, echo = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
sizes <- c(1, 2, 4, 8)

expr_plots <- map2(genes, sizes, ~ {
  plot_expr(
    input    = brauer_gene_exp,
    sys_name = .x,
    size     = .y
  )
})

plot_grid(plotlist = expr_plots)
```

<br>

`pmap` can be used to map over any number of arguments.
```{r, fig.width = 10, fig.height = 8}
# Create a list of input vectors
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
sizes <- c(2, 3, 4, 5)
shapes <- c(1, 2, 3, 4)

plot_args <- list(genes, sizes, shapes)

# Run use argument list with pmap
expr_plots <- pmap(plot_args, ~ {
  plot_expr(
    input = brauer_gene_exp,
    sys_name = ..1,
    size     = ..2,
    shape    = ..3
  )
})

# A simpler way
plot_args <- list(
  sys_name = c("YDL104C", "YOR069W", "YLR115W", "YPR036W"),
  size     = c(2, 3, 4, 5),
  shape    = c(1, 2, 3, 4)
)

expr_plots <- pmap(
  .l = plot_args, 
  .f = plot_expr, 
  input = brauer_gene_exp
)

plot_grid(plotlist = expr_plots)
```

<br>

<br>

## More exercises
(@) Write a function that has two arguments (data, systematic_name) and creates the following plot
```{r, echo = F}
plot_expr_2 <- function(input, sys_name) {
  
  gg_data <- input %>% 
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) + 
    geom_point() + 
    geom_smooth(method = "lm", se = F) +
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
}
```

```{r, fig.width = 6, fig.height = 4}
plot_expr_2(
  input = brauer_gene_exp, 
  sys_name = "YDL104C"
)
```

<br>

<br>

(@) Add an argument to hide the figure legend
```{r, echo = F}
plot_expr_3 <- function(input, sys_name, hide_legend = F) {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point() +
    geom_smooth(method = "lm", se = F) +
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
  
  if (hide_legend) {
    res <- res +
      theme(legend.position = "none")
  }
  
  res
}
```

```{r, fig.width = 6, fig.height = 3.5}
plot_expr_3(
  input = brauer_gene_exp,
  sys_name = "YDL104C",
  hide_legend = T
)
```

<br>

<br>

(@) Use your function with `map()` to create a figure containing plots for four genes
```{r, fig.width = 10, fig.height = 6.5, echo = F}
sys_names <- c("YNL049C", "YNL095C", "YDL104C", "YLR115W")

expr_plots <- map(
  .x = sys_names, 
  .f = plot_expr_3, 
  input = brauer_gene_exp
)

plot_grid(plotlist = expr_plots)
```

<br>

<br>

(@) Modify your function so the points are red if the mean expression is >-0.1
```{r, echo = F}
plot_expr_4 <- function(input, sys_name, hide_legend = F) {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_smooth(method = "lm", se = F) +
    geom_point() +
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
  
  if (hide_legend) {
    res <- res +
      theme(legend.position = "none")
  }
  
  mean_exp <- mean(gg_data$expression)
  
  if (mean_exp > -0.1) {
    res <- res +
      geom_point(color = "red")
  }
  
  res
}
```

```{r, fig.width = 6, fig.height = 3.5}
plot_expr_4(
  input = brauer_gene_exp,
  sys_name = "YNL049C"
)
```

<br>

<br>

(@) Add arguments that let the user set the mean expression cutoff and the point color when the mean is greater than the cutoff
```{r, echo = F}
plot_expr_5 <- function(input, sys_name, hide_legend = F, exp_cutoff = -0.1, 
                        exp_color = "red") {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_smooth(method = "lm", se = F) +
    geom_point() +
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
  
  if (hide_legend) {
    res <- res +
      theme(legend.position = "none")
  }
  
  mean_exp <- mean(gg_data$expression)
  
  if (mean_exp > exp_cutoff) {
    res <- res +
      geom_point(color = exp_color)
  }
  
  res
}
```

```{r, fig.width = 6, fig.height = 3.5}
plot_expr_5(
  input = brauer_gene_exp,
  sys_name = "YNL049C",
  exp_cutoff = -0.1,
  exp_color = "blue"
)
```

<br>

<br>

(@) Modify your function so each rate is represented by a different point shape (and hide the legend for shape)
```{r, echo = F}
plot_expr_6 <- function(input, sys_name, hide_legend = F, 
                        exp_cutoff = -0.1, exp_color = "red") {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_smooth(method = "lm", se = F) +
    geom_point(aes(shape = as.character(rate)), show.legend = F) +
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
  
  if (hide_legend) {
    res <- res +
      theme(legend.position = "none")
  }
  
  mean_exp <- mean(gg_data$expression)
  
  if (mean_exp > exp_cutoff) {
    res <- res +
      geom_point(aes(shape = as.character(rate)), color = exp_color, show.legend = F)
  }
  
  res
}
```

```{r, fig.width = 10, fig.height = 3.5}
p_1 <- plot_expr_6(
  input = brauer_gene_exp,
  sys_name = "YNL049C",
  exp_cutoff = 10,
  hide_legend = T
)

p_2 <- plot_expr_6(
  input = brauer_gene_exp,
  sys_name = "YNL049C",
  exp_cutoff = -0.1,
  exp_color = "blue"
)

plot_grid(
  p_1, p_2, 
  nrow = 1, 
  rel_widths = c(0.44, 0.56)
)
```

<br>

<br>

(@) Use the ellipsis to pass arguments directly to `theme()`
```{r, echo = F}
plot_expr_7 <- function(input, sys_name, hide_legend = F, exp_cutoff = -0.1, 
                        exp_color = "red", ...) {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_smooth(method = "lm", se = F) +
    geom_point(aes(shape = as.character(rate)), show.legend = F) +
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot() +
    theme(...)
  
  if (hide_legend) {
    res <- res +
      theme(legend.position = "none")
  }
  
  mean_exp <- mean(gg_data$expression)
  
  if (mean_exp > exp_cutoff) {
    res <- res +
      geom_point(aes(shape = as.character(rate)), color = exp_color, show.legend = F)
  }
  
  res
}
```

```{r, fig.width = 6, fig.height = 3.5}
plot_expr_7(
  input        = brauer_gene_exp,
  sys_name     = "YNL049C",
  exp_cutoff   = -0.1,
  axis.title.x = element_blank(),
  axis.text.y  = element_text(size = 20),
  plot.title   = element_text(face = "italic")
)
```

<br>

<br>

(@) Modify your function to take a vector of systematic_names to create the following plot
```{r, echo = F}
plot_expr_8 <- function(input, sys_name, hide_legend = F, exp_cutoff = -0.1, 
                        exp_color = "red", ...) {
  
  gg_data <- input %>%
    filter(systematic_name %in% sys_name)
  
  res <- gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_smooth(method = "lm", se = F) +
    geom_point(aes(shape = as.character(rate)), show.legend = F) +
    facet_wrap(~ systematic_name) +
    theme_cowplot() +
    theme(...)
  
  if (hide_legend) {
    res <- res +
      theme(legend.position = "none")
  }
  
  mean_exp <- mean(gg_data$expression)
  
  if (mean_exp > exp_cutoff) {
    res <- res +
      geom_point(aes(shape = as.character(rate)), color = exp_color, show.legend = F)
  }
  
  res
}
```

```{r, fig.width = 10, fig.height = 6.5}
name_vec <- c("YNL049C", "YNL095C", "YDL104C", "YLR115W")

plot_expr_8(
  input        = brauer_gene_exp,
  sys_name     = name_vec,
  exp_cutoff   = -0.1,
  axis.title.x = element_blank(),
  axis.text.y  = element_text(size = 20),
  plot.title   = element_text(face = "italic")
)
```


