---
title: "Programming concepts"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_float: true
    toc_depth: 3
editor_options: 
  chunk_output_type: inline
---

```{r setup, include = F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "left"
)
library(pbda)
library(tidyverse)
library(cowplot)
```

## Functions

### What is a function?
As an analyst you will eventually find yourself in the position of wanting to reuse a block of code. There are two general ways to do this:

1. copy-and-paste
2. write a function

A function is essentially a block of code that you've given a name and saved for later. Functions have several advantages:

* They make your code easier to read
* They reduce the chance of mistakes from repeated copying and pasting
* They make it easier to adapt your code for different requirements

Further reading

* [R for Data Science](https://r4ds.had.co.nz) by Garrett Grolemund and Hadley Wickham
* [Advanced R](https://adv-r.hadley.nz) by Hadley Wickham
```{r}
# An example: you want to rescale a numeric vector so all values are between 0 and 1
a <- rnorm(n = 10)
a

rng <- range(a)
(a - rng[1]) / (rng[2] - rng[1])

# What if we want to repeat this on other vectors?
# One way is to copy and paste
b <- rnorm(n = 10)
c <- rnorm(n = 10)

rng <- range(b)
new_b <- (b - rng[1]) / (rng[2] - rng[1])

rng <- range(c)
new_c <- (c - rng[1]) / (rng[2] - rng[1])

# A better way is to write a function...
```

<br>

<br>

### Function structure
There are three general steps for writing functions:

1. Pick a name
2. Identify the inputs
3. Add code to the body
```{r, eval = F}
# Lets write a function to rescale a numeric vector
rescale_vec <- function(x) {
  
  rng <- range(x)
  (x - rng[1]) / (rng[2] - rng[1])

}

rescale_vec(b)
rescale_vec(c)
```

<br>

*Write functions for the following bits of code*
```{r, eval = F}
# function 1
x / sum(x)

# function 2
(x + y) / z

# function 3
sqrt(sum((x - mean(x))^2) / (length(x) - 1))
```

```{r, echo = F}
calc_sd <- function(x) {
  sqrt(sum((x - mean(x))^2) / (length(x) - 1))
}

calc_sd <- function(x) {
  l <- length(x) - 1
  m <- mean(x)
  v <- sum((x - m)^2) / l
  sqrt(v)
}
```

<br>

<br>

### The function execution environment
- When running a function an execution environment is created, which is separate from the global environment
- The execution environment contains objects created within the function
- The execution environment follows the "fresh start" principle
- When R searches for an object referenced by a function, the execution environment takes precedence

<br>

*Can objects present in the global environment be referenced from within a function?*
```{r}
# Earlier we saved a numeric vector "a"
a

sum_nums <- function(x) {
  x + a
}

# Yes!
sum_nums(10)
```

<br>

*Can code executed within a function modify an object present in the global environment?*
```{r}
sum_nums <- function(x) {
  a <- x + a
}

# When we run sum_nums(), will this overwrite our original vector?
sum_nums(10)

# No! (not when using the '<-' assignment operator)
a
```

<br>

<br>

### A more relevant example
*Using the Brauer data lets create a scatter plot comparing growth rate vs expression for the gene YDL104C. Use `facet_wrap()` to create a separate plot for each nutrient.*
```{r, fig.width = 6, fig.height = 4.5, echo = F}
gg_data <- brauer_gene_exp %>%
  filter(systematic_name == "YDL104C")               # Filter for gene of interest

gg_data %>%
  ggplot(aes(rate, expression, color = nutrient)) +  # Create scatter plot
  geom_point(size = 2) +
  facet_wrap(~ nutrient) +                           # Create separate plot for each nutrient
  theme(legend.position = "none")
```

<br>

What if you want to create this plot for other genes? *Write a function the takes a data.frame and systematic_name as inputs and creates scatter plots for each nutrient*
```{r, eval = F}
# Fill in the function body
# You can include default values for your arguments
plot_expr <- function(input, sys_name = "YNL049C") {
  
  ????
  
}
```

```{r, echo = F}
plot_expr <- function(input, sys_name = "YNL049C") {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, fig.width = 6, fig.height = 4.5}
p <- plot_expr(
  input = brauer_gene_exp, 
  sys_name = "YDL104C"
)

# You can also use the %>% pipe with your custom functions
p <- brauer_gene_exp %>%
  plot_expr(sys_name = "YDL104C")

p
```

<br>

*Modify our plotting function to add the gene name as the plot title and the molecular function (MF) as a subtitle*
```{r, echo = F}
plot_expr <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    ggtitle(plot_title) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, fig.width = 6, fig.height = 4.5}
brauer_gene_exp %>%
  plot_expr("YDL104C")
```

<br>

<br>

### Conditional statements
`if` statements allow you to execute code depending on defined conditions.
```{r, eval = F}
if (condition) {
  code executed when condition is TRUE
  
} else {
  code executed when condition is FALSE
}
```

R has a set of operators that can be used to write conditional statements

Operator | Description
:-------:|:-----------
<        | less than
<=       | less or equal
\>       | greater than
\>=      | greater or equal
==       | equal
!=       | not equal
!x       | not x
x \|\| y | x or y
x && y   | x and y
x %in% y | x is present in y

<br>

*Add an `if` statement to our plotting function to account for a missing gene name*
```{r, eval = F}
plot_expr <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  ????
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, echo = F}
plot_expr <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, fig.width = 6, fig.height = 4.5}
brauer_gene_exp %>%
  plot_expr("YNL095C")
```

<br>

Conditional statements can be linked together
```{r, eval = F}
# Using 'else if'
if (condition_1) {
  executed when condition_1 is TRUE
  
} else if (condition_2) {
  executed when condition_1 is FALSE and condition_2 is TRUE
  
} else {
  executed when condition_1 and condition_2 are FALSE
}

# The 'and' operator
if (condition_1 && condition_2) {
  executed when condition_1 and condition_2 are TRUE
  
} else {
  executed when condition_1 or condition_2 are FALSE
}

# The 'or' operator
if (condition_1 || condition_2) {
  executed when condition_1 or condition_2 are TRUE
  
} else {
  executed when condition_1 and condition_2 are FALSE
}
```

<br>

<br>

### Checking inputs
When writing functions it can be useful to check input values to make sure they are valid. Lets modify our plotting function to check that `sys_name` is a string.

- `is.character()`
- `is.numeric()`
- `is.logical()`
- `is.factor()`

```{r, fig.width = 6, fig.height = 4.5}
plot_expr <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_expr("YDL104C")
```

<br>

*Modify our plotting function to check that `sys_name` is present in the input. Hint: try the `%in%` operator*
```{r, eval = F}
plot_expr <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  if ( ???? ) {
    stop( ???? )
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

```{r, echo = F}
plot_expr <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  if (!sys_name %in% input$systematic_name) {
    stop("sys_name not found in input data!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}
```

<br>

<br>

### Passing arguments with the ellipsis (...)
The ellipsis allows a function to take an arbitrary number of arguments, which can then be passed to an inner function. This is nice when you have an inner function that has a lot of useful arguments. Lets first try this with our simple `rescale_vec()` function. 
```{r}
rescale_vec <- function(x, ...) {
  rng <- range(x, ...)
  (x - rng[1]) / (rng[2] - rng[1])
}

rescale_vec(a)

a[1] <- NA

rescale_vec(a, na.rm = T)
```

<br>

*Modify our plotting function so the user can change the point size, shape, and alpha*
```{r, fig.width = 6, fig.height = 4.5}
# A cumbersome way
plot_expr <- function(input, sys_name, pt_size = 2, pt_shape = 1, pt_alpha = 1) {
  input %>%
    filter(systematic_name == sys_name) %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = pt_size, shape = pt_shape, alpha = pt_alpha) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

# With the ellipsis
plot_expr <- function(input, sys_name, ...) {
  input %>%
    filter(systematic_name == sys_name) %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(...) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

# Now we can easily change the point size and shape
plot_expr(
  input = brauer_gene_exp,
  sys_name = "YDL104C",
  size = 5,
  shape = 2,
  alpha = 0.5
)
```

<br>

<br>

### Saving your functions for later
A good way to save commonly used functions is to keep them in a separate R script. You can load your functions using the `source()` command.
```{r, eval = F}
source("path/to/my_functions.R")
```

<br>

<br>

## Iteration

### `for` loops
As discussed in the previous section, you should try to limit duplication in your code. One way to do this is by writing functions, another way is through iteration. `for` loops allow you to run the same code block repeatedly without copying and pasting.
```{r}
# When writing a for loop, think about the output, sequence, and body
out <- vector("numeric", 5)  # output

for (i in 1:length(out)) {   # sequence
  
  out[i] <- i * 5            # body
  
}

# It's helpful to think about what happens during each cycle of the loop
out[1] <- 1 * 5  # i = 1
out[2] <- 2 * 5  # i = 2
out[3] <- 3 * 5  # i = 3
out[4] <- 4 * 5  # i = 4
out[5] <- 5 * 5  # i = 5
```

```{r}
# Lets use rnorm() to create 5 vectors with different values for 'mean'
# One way to do this is by copying and pasting
vec_in <- c(1, 50, 20, 5, 70)                # input

out <- vector("list", length(vec_in))        # output

out[[1]] <- rnorm(n = 10, mean = vec_in[1])    
out[[2]] <- rnorm(n = 10, mean = vec_in[2])
out[[3]] <- rnorm(n = 10, mean = vec_in[3])
out[[4]] <- rnorm(n = 10, mean = vec_in[4])
out[[5]] <- rnorm(n = 10, mean = vec_in[5])

# Use a for loop to reduce code duplication
vec_in <- c(1, 50, 20, 5, 70)                  # input

out <- vector("list", length(vec_in))          # output

for (i in 1:length(vec_in)) {                  # sequence
  
  out[[i]] <- rnorm(n = 10, mean = vec_in[i])  # body
  
}
```

<br>

*Write a `for` loop to create 3 vectors of different lengths*
```{r, echo = F}
vec_in <- c(5, 10, 2)                  # input

out <- vector("list", length(vec_in))  # output

for (i in 1:length(vec_in)) {          # sequence
  
  out[[i]] <- rnorm(n = vec_in[i])     # body
  
}

out
```

<br>

Using `seq_along(x)` instead of `1:length(x)`
```{r}
# seq_along() mimics 1:length() for non-empty vectors
vec_in <- c(5, 10, 2)

1:length(vec_in)

seq_along(vec_in)

# seq_along() correctly handles empty vectors
emp_vec <- vector("numeric", 0)

1:length(emp_vec)

seq_along(emp_vec)
```

<br>

<br>

### Lets try this with the Brauer data
```{r, fig.width = 10, fig.height = 8}
# We want to create a supplemental figure showing the growth rate vs expression for four genes
plot_expr <- function(input, sys_name, ...) {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(...) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme_cowplot() +
    theme(legend.position = "none")
}

# Lets try this with the copy-and-paste method
vec_in <- c("YDL104C", "YLR115W", "YMR183C", "YML017W")       # input

out <- vector("list", length(vec_in))                         # output 

out[[1]] <- plot_expr(brauer_gene_exp, sys_name = vec_in[1])  
out[[2]] <- plot_expr(brauer_gene_exp, sys_name = vec_in[2])
out[[3]] <- plot_expr(brauer_gene_exp, sys_name = vec_in[3])
out[[4]] <- plot_expr(brauer_gene_exp, sys_name = vec_in[4])

plot_grid(plotlist = out)
```

<br>

*Re-write the code from above using a `for` loop to generate our figure*
```{r, eval = F}
vec_in <- c("YDL104C", "YLR115W", "YMR183C", "YML017W")  # input

out <- vector("list", length(vec_in))                    # output

for ( ???? ) {                                           # sequence
  
                                                         # body

}

plot_grid(plotlist = out)
```

<br>

<br>

### Introduction to `map()`
`for` loops are a powerful tool to reduce code duplication, however your code can be further simplified using the `map()` functions provided in the purrr package. These `map()` functions essentially run `for (i in seq_along(x))` behind the scenes so you don't have to explicitly type this.

There is a function for each type of output:

- `map()` makes a list
- `map_lgl()` makes a logical vector
- `map_int()` makes an integer vector
- `map_dbl()` makes a double vector
- `map_chr()` makes a character vector

Each `map()` function requires two inputs: `map(.x, .f, ...)`

- `.x` is a list or atomic vector
- `.f` is a function or formula
```{r}
# We previously used a for loop to create vectors with different values for mean
vals <- c(1, 50, 20, 5, 70)                  # input

out <- vector("list", length(vals))          # output

for (i in seq_along(vals)) {                 # sequence
  
  out[[i]] <- rnorm(n = 10, mean = vals[i])  # body
  
}

# Using map() we can further simplify this code
# .x indicates where each element of the vector should be inserted
out <- map(
  .x = vals,
  .f = ~ rnorm(n = 10, mean = .x)
)

# You can use brackets to include a multi-line code block
out <- map(vals, ~ {
  
  rnorm(n = 10, mean = .x)

})

# map() allows for very readable code
# Each element of the vector is passed to the first available argument
out <- map(vals, rnorm, n = 10)
```

<br>

*Use `rnorm()` and `map()` to create 3 vectors of different lengths*
```{r, echo = F}
lens <- c(5, 10, 2)

out <- map(lens, ~ rnorm(n = .x))

out <- map(lens, rnorm)

out
```

<br>

*Re-write the code from above using `map()` to generate our growth rate figure*
```{r, eval = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

expr_plots <- map(
  
  ????
  
)

plot_grid(plotlist = expr_plots)
```

```{r, fig.width = 10, fig.height = 8, echo = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

expr_plots <- map(
  .x = genes, 
  .f = plot_expr, 
  input = brauer_gene_exp
)

plot_grid(plotlist = expr_plots)
```

<br>

<br>

### Mapping over multiple arguments
If you have two vectors containing values that you want to pass to a function this can be accomplished with `map2()`.
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
shapes <- c(1, 2, 3, 4)

expr_plots <- map2(genes, shapes, ~ {
  plot_expr(
    input    = brauer_gene_exp,
    sys_name = .x,
    shape    = .y
  )
})

plot_grid(plotlist = expr_plots)
```

<br>

*Use `map2()` to create plots for 4 different genes, each with a different point size*
```{r, eval = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

expr_plots <- map2(
  
  ????
  
)

plot_grid(plotlist = expr_plots)
```

```{r, fig.width = 10, fig.height = 8, echo = F}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
sizes <- c(1, 2, 4, 8)

expr_plots <- map2(genes, sizes, ~ {
  plot_expr(
    input    = brauer_gene_exp,
    sys_name = .x,
    size     = .y
  )
})

plot_grid(plotlist = expr_plots)
```

<br>

`pmap` can be used to map over any number of arguments.
```{r, fig.width = 10, fig.height = 8}
# Create a list of input vectors
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
sizes <- c(2, 3, 4, 5)
shapes <- c(1, 2, 3, 4)

plot_args <- list(genes, sizes, shapes)

# Use an argument list with pmap
expr_plots <- pmap(plot_args, ~ {
  plot_expr(
    input = brauer_gene_exp,
    sys_name = ..1,
    size     = ..2,
    shape    = ..3
  )
})

# A simpler way
plot_args <- list(
  sys_name = c("YDL104C", "YOR069W", "YLR115W", "YPR036W"),
  size     = c(2, 3, 4, 5),
  shape    = c(1, 2, 3, 4)
)

expr_plots <- pmap(
  .l = plot_args, 
  .f = plot_expr, 
  input = brauer_gene_exp
)

plot_grid(plotlist = expr_plots)
```

<br>

<br>

## Problem set 2

### Question 1

Write a function that plots rate vs expression when provided a data.frame, a systematic_name, and a nutrient. Add the common gene name as a title and the nutrient as a subtitle. Include an argument that lets the user select whether a regression line is shown.
```{r, echo = F}
plot_expr <- function(input, sys_name, nutri, add_lm = F) {
  gg_data <- input %>%
    filter(
      systematic_name == sys_name,
      nutrient == nutri
    )
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$nutrient[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression)) + 
    geom_point(size = 3, color = "blue") + 
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
  
  if (add_lm) {
    res <- res +
      geom_smooth(
        method = "lm", 
        se = F, 
        size = 0.5, 
        linetype = 2, 
        color = "black"
      )
  }
  
  res
}
```

```{r, fig.width = 6, fig.height = 3.5}
plot_expr(
  input = brauer_gene_exp, 
  sys_name = "YDL104C",
  nutri = "Ammonia",
  add_lm = T
)
```

<br>

<br>

### Question 2

Add an `if` statement to check whether the systematic_name and nutrient provided by the user are present in the input data.
```{r, echo = F}
plot_expr <- function(input, sys_name, nutri, add_lm = F) {
  
  if (!sys_name %in% input$systematic_name || !nutri %in% input$nutrient) {
    stop("sys_name and nutri must be present in the input data!", call. = F)
  }
  
  gg_data <- input %>%
    filter(
      systematic_name == sys_name,
      nutrient == nutri
    )
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$nutrient[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression)) + 
    geom_point(size = 3, color = "blue") + 
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
  
  if (add_lm) {
    res <- res +
      geom_smooth(
        method = "lm", 
        se = F, 
        size = 0.5, 
        linetype = 2, 
        color = "black"
      )
  }
  
  res
}
```

```{r, fig.width = 6, fig.height = 3.5, eval = F}
plot_expr(
  input = brauer_gene_exp,
  sys_name = "YDL104CZZZZZZZ",
  nutri = "Ammonia",
  add_lm = T
)
```

```{r, echo = F}
print("Error: sys_name and nutri must be present in the input data!")
```


<br>

<br>

### Question 3 

Add the ellipsis so the user can pass arguments directly to `theme()`.
```{r, echo = F}
plot_expr <- function(input, sys_name, nutri, add_lm = F, ...) {
  
  if (!sys_name %in% input$systematic_name || !nutri %in% input$nutrient) {
    stop("sys_name and nutri must be present in the input data!")
  }
  
  gg_data <- input %>%
    filter(
      systematic_name == sys_name,
      nutrient == nutri
    )
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$nutrient[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression)) + 
    geom_point(size = 3, color = "blue") + 
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot() +
    theme(...)
  
  if (add_lm) {
    res <- res +
      geom_smooth(
        method = "lm", 
        se = F, 
        size = 0.5, 
        linetype = 2, 
        color = "black"
      )
  }
  
  res
}
```

```{r, fig.width = 6, fig.height = 3.5}
plot_expr(
  input = brauer_gene_exp,
  sys_name = "YDL104C",
  nutri = "Ammonia",
  add_lm = T,
  axis.title = element_text(size = 20),
  axis.text = element_text(face = "italic")
)
```

<br>

<br>

### Question 4

Use your function with `map()` to create a figure containing plots for four genes.
```{r, fig.width = 10, fig.height = 6.5, echo = F}
sys_names <- c("YNL049C", "YML017W", "YDL104C", "YLR115W")

expr_plots <- map(
  .x = sys_names, 
  .f = plot_expr, 
  input = brauer_gene_exp,
  nutri = "Ammonia",
  add_lm = T,
  axis.title = element_text(size = 20),
  axis.text = element_text(face = "italic")
)

plot_grid(plotlist = expr_plots)
```


