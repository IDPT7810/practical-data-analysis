---
title: "Programming concepts"
author: "Ryan Sheridan"
date: "`r Sys.Date()`"
# output: rmarkdown::html_vignette
# vignette: >
#  %\VignetteIndexEntry{Class-8}
#  %\VignetteEngine{knitr::rmarkdown}
#  %\VignetteEncoding{UTF-8}
---

```{r setup, include = F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "left"
)
library(pbda)
library(tidyverse)
library(cowplot)
```

## Functions

### What is a function?
As an analyst you will eventually find yourself in the position of wanting to reuse a block of code. There are two general ways to do this:

1. copy-and-paste
2. write a function

A function is essentially a block of code that you've given a name and saved for later. Functions have several advantages:

* They make your code easier to read
* They reduce the chance of mistakes from repeated copying and pasting
* They make it easier to adapt your code for different requirements
```{r}
# An example: you want to rescale a numeric vector so all values are between 0 and 1
a <- rnorm(n = 10)
a

rng <- range(a)
(a - rng[1]) / (rng[2] - rng[1])

# What if we want to repeat this on other vectors?
b <- rnorm(n = 10)
c <- rnorm(n = 10)

rng <- range(b)
new_b <- (b - rng[1]) / (rng[2] - rng[1])

rng <- range(c)
new_c <- (c - rng[1]) / (rng[2] - rng[1])
```

<br>

---

<br>

### Function structure
There are three general steps for writing functions:

1. Pick a name
2. Identify the inputs
3. Add code to the body
```{r, eval = F}
rescale_vec <- function(x) {
  rng <- range(x)
  (x - rng[1]) / (rng[2] - rng[1])
}

rescale_vec(b)
rescale_vec(c)
```

<br>

*Write functions for the following bits of code*
```{r, eval = F}
# function 1
x / sum(x)

# function 2
(x + y) / z

# function 3
sqrt(sum((x - mean(x))^2) / (length(x) - 1))
```

```{r, echo = F}
calc_sd <- function(x) {
  sqrt(sum((x - mean(x))^2) / (length(x) - 1))
}

calc_sd <- function(x) {
  l <- length(x) - 1
  m <- mean(x)
  v <- sum((x - m)^2) / l
  sqrt(v)
}
```

<br>

---

<br>

### The function execution environment
- When running a function an execution environment is created, which is separate from the global environment
- The execution environment consists of objects created by the function
- The execution environment follows the "fresh start" principle
- When R searches for an object referenced by a function, the execution environment takes precedence

<br>

*Can objects present in the global environment be referenced from within a function?*
```{r}
# Earlier we saved a numeric vector "a"
a

sum_nums <- function(x) {
  x + a
}

# Yes!
sum_nums(10)
```

<br>

*Can code executed within a function modify an object present in the global environment?*
```{r}
sum_nums <- function(x) {
  a <- x + a
}

# When we run sum_nums(), will this overwrite our original vector?
sum_nums(10)

# No! (not when using the '<-' assignment operator)
a
```

<br>

---

<br>

### A more relevant example
Lets create a scatter plot comparing growth rate vs expression for the gene YDL104C. We can use `facet_wrap()` to create a separate plot for each nutrient.
```{r, fig.width = 6, fig.height = 4.5}
gg_data <- brauer_gene_exp %>%
  filter(systematic_name == "YDL104C")               # Filter for gene of interest

gg_data %>%
  ggplot(aes(rate, expression, color = nutrient)) +  # Create scatter plot
  geom_point(size = 2) +
  facet_wrap(~ nutrient) +                           # Create separate plot for each nutrient
  theme(legend.position = "none")
```

<br>

What if you want to create this plot for multiple genes? *Write a function the takes a data.frame and systematic_name as inputs and creates scatter plots for each nutrient*
```{r, fig.width = 6, fig.height = 4.5}
plot_expr <- function(input, sys_name = "YNL049C") {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

plot_expr(
  input = brauer_gene_exp, 
  sys_name = "YDL104C"
)
```

<br>

*Modify our plotting function to add the gene name as the plot title and the molecular function (MF) as a subtitle*
```{r, fig.width = 6, fig.height = 4.5}
plot_expr <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    ggtitle(plot_title) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_expr("YDL104C")
```

<br>

---

<br>

### Conditional statements
`if` statements allow you to execute code depending on defined conditions.
```{r, eval = F}
if (condition) {
  code executed when condition is TRUE
  
} else {
  code executed when condition is FALSE
}
```

R has a set of operators that can be used to write conditional statements

Operator | Description
:-------:|:-----------
<        | less than
<=       | less or equal
\>       | greater than
\>=      | greater or equal
==       | equal
!=       | not equal
!x       | not x
x \|\| y | x or y
x && y   | x and y
x %in% y | x is present in y

<br>

*Add an `if` statement to our plotting function to account for a missing gene name*
```{r, fig.width = 6, fig.height = 4.5}
plot_expr <- function(input, sys_name) {
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_expr("YNL095C")
```

<br>

Conditional statements can be linked together
```{r, eval = F}
if (condition_1) {
  executed when condition_1 is TRUE
  
} else if (condition_2) {
  executed when condition_2 if TRUE
  
} else {
  executed when condition_1 and condition_2 are FALSE
}


if (condition_1 && condition_2) {
  executed when condition_1 and condition_2 are TRUE
  
} else {
  executed when condition_1 or condition_2 are FALSE
}


if (condition_1 || condition_2) {
  executed when condition_1 or condition_2 are TRUE
  
} else {
  executed when condition_1 and condition_2 are FALSE
}
```

<br>

---

<br>

### Checking inputs
When writing functions it can be useful to check input values to make sure they are valid. Lets modify our plotting function to check that `sys_name` is a string.

- `is.character()`
- `is.numeric()`
- `is.logical()`
- `is.factor()`

```{r, fig.width = 6, fig.height = 4.5}
plot_expr <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_expr("YDL104C")
```

<br>

*Modify our plotting function to check that `sys_name` is present in the input. Hint: use the `%in%` operator*
```{r, fig.width = 6, fig.height = 4.5}
plot_expr <- function(input, sys_name) {
  
  if (!is.character(sys_name)) {
    stop("sys_name must be a string!")
  }
  
  if (!sys_name %in% input$systematic_name) {
    stop("sys_name not found in input data!")
  }
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(size = 2) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_expr("YDL104C")
```

<br>

---

<br>

### Passing arguments with the ellipsis (...)
The ellipsis allows a function to take an arbitrary number of arguments, which can then be passed to other functions. Lets first try this using our simple `rescale_vec()` function. 
```{r}
rescale_vec <- function(x, ...) {
  x_rng <- range(x, ...)
  (x - x_rng[1]) / (x_rng[2] - x_rng[1])
}

rescale_vec(a)

a[1] <- NA

rescale_vec(a, na.rm = T)
```

<br>

*Modify our plotting function to pass arguments through the ellipsis to ggplot*
```{r, fig.width = 6, fig.height = 4.5}
plot_expr <- function(input, sys_name, ...) {
  
  input %>%
    filter(systematic_name == sys_name) %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(...) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

brauer_gene_exp %>%
  plot_expr(
    sys_name = "YDL104C",
    size = 3,
    shape = 2
  )
```

<br>

---

<br>

### Saving your functions for later
A good way to save commonly used functions is to keep them in a separate R script. You can load your functions using the `source()` command.
```{r, eval = F}
source("path/to/my_functions.R")
```

<br>

---

<br>

## Iteration

### `for` loops
As discussed in the previous section, it is good practice to try to limit duplication in your code. One way to do this is by writing functions, another way is through iteration. `for` loops allow you to run the same code block repeatedly without copying and pasting.
```{r}
for (i in 1:5) {
  print(i)
}

# Maybe instead of printing, we want to save these new values
out <- vector("numeric", 5)

for (i in 1:length(out)) {
  out[i] <- 2 * i
}

# Lets use rnorm() to create 5 vectors with different values for 'mean'
# One way to do this is to through copying and pasting
out <- vector("list", 5)

out[[1]] <- rnorm(n = 10, mean = 1)
out[[2]] <- rnorm(n = 10, mean = 50)
out[[3]] <- rnorm(n = 10, mean = 20)
out[[4]] <- rnorm(n = 10, mean = 5)
out[[5]] <- rnorm(n = 10, mean = 70)

# Use a for loop to reduce code duplication
# seq_along() is a safer way of writing 1:length(x)
vals <- c(1, 50, 20, 5, 70)
out <- vector("list", length(vals))

for (i in seq_along(vals)) {
  out[[i]] <- rnorm(n = 10, mean = vals[i])
}
```

<br>

*Write a `for` loop to create 5 vectors of different lengths*
```{r}
lens <- c(2, 5, 20, 15, 3)
out <- vector("list", length(lens))

for (i in seq_along(lens)) {
  out[[i]] <- rnorm(n = lens[i])
}
```

<br>

---

<br>

### Lets try this with the Brauer gene expression data
```{r, fig.width = 10, fig.height = 8}
plot_expr <- function(input, sys_name, ...) {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  if (plot_title == "") {
    plot_title <- sys_name
  }
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point(...) +
    labs(title = plot_title, subtitle = plot_sub) +
    facet_wrap(~ nutrient) +
    theme(legend.position = "none")
}

growth_plots <- vector("list", 4)

growth_plots[[1]] <- brauer_gene_exp %>%
  plot_expr(sys_name = "YDL104C")

growth_plots[[2]] <- brauer_gene_exp %>%
  plot_expr(sys_name = "YOR069W")

growth_plots[[3]] <- brauer_gene_exp %>%
  plot_expr(sys_name = "YLR115W")

growth_plots[[4]] <- brauer_gene_exp %>%
  plot_expr(sys_name = "YPR036W")

plot_grid(plotlist = growth_plots)
```

<br>

*Re-write the code from above using a for loop to generate our growth rate figure*
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
growth_plots <- vector("list", 4)

for (i in seq_along(growth_plots)) {
  growth_plots[[i]] <- brauer_gene_exp %>%
    plot_expr(
      sys_name = genes[i],
      size  = 3,
      shape = 5
    )
}

plot_grid(plotlist = growth_plots)
```

<br>

---

<br>

### Introduction to `purrr::map`
`for` loops are a powerful tool to reduce code duplication, however your code can be further simplified using the `map()` functions provided in the purrr package. These `map()` functions essentially run `for (i in seq_along(x))` behind the scenes so you don't have to explicitly type this.

There is a function for each type of output:

- `map()` makes a list
- `map_lgl()` makes a logical vector
- `map_int()` makes an integer vector
- `map_dbl()` makes a double vector
- `map_chr()` makes a character vector

Each `map()` function requires two inputs: `map(.x, .f, ...)`

- `.x` is a list or atomic vector
- `.f` is a function or formula
```{r}
# We previously used a for loop to create vectors with different means
vals <- c(1, 50, 20, 5, 70)
out <- vector("list", length(vals))

for (i in seq_along(vals)) {
  out[[i]] <- rnorm(n = 10, mean = vals[i])
}

# Using map() we can further simplify this code
# Each element of the vector is passed to the first available argument
out <- map(vals, ~ rnorm(n = 10, mean = .x))

out <- map(vals, rnorm, n = 10)
```

<br>

*Use `rnorm()` and `map()` to create 5 vectors of different lengths*
```{r}
lens <- c(2, 5, 20, 15, 3)

out <- map(lens, ~ rnorm(n = .x))

out <- map(lens, rnorm)
```

<br>

*Re-write the code from above using `map()` to generate our growth rate figure*
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")

growth_plots <- map(genes, plot_expr, input = brauer_gene_exp)

plot_grid(plotlist = growth_plots)
```

<br>

---

<br>

### Mapping over multiple arguments
If you have two vectors containing values that you want to pass to a function this can be accomplished with `map2()`.
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
shapes <- c(1, 2, 3, 4)

growth_plots <- map2(genes, shapes, ~ {
  plot_expr(
    input    = brauer_gene_exp,
    sys_name = .x,
    shape    = .y
  )
})

plot_grid(plotlist = growth_plots)
```

<br>

*Use `map2()` to create plots for 4 different genes, each with a different line size*
```{r, fig.width = 10, fig.height = 8}
genes <- c("YDL104C", "YOR069W", "YLR115W", "YPR036W")
sizes <- c(1, 2, 3, 4)

growth_plots <- map2(genes, sizes, ~ {
  plot_expr(
    input    = brauer_gene_exp,
    sys_name = .x,
    size     = .y
  )
})

plot_grid(plotlist = growth_plots)
```

<br>

`pmap` can be used to map over any number of arguments.
```{r, fig.width = 10, fig.height = 8}
plot_args <- list(
  sys_name = c("YDL104C", "YOR069W", "YLR115W", "YPR036W"),
  size = c(2, 3, 4, 5),
  shape = c(1, 2, 3, 4)
)

growth_plots <- pmap(plot_args, plot_expr, brauer_gene_exp)

plot_grid(plotlist = growth_plots)
```

<br>

---

<br>

## More exercises
*Write a function that has two arguments (data, systematic_name) and creates the following plot*
```{r, echo = F}
plot_expr_2 <- function(input, sys_name) {
  
  gg_data <- input %>% 
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) + 
    geom_point() + 
    geom_smooth(method = "lm", se = F) +
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
}
```

```{r, fig.width = 6, fig.height = 4}
plot_expr_2(
  input = brauer_gene_exp, 
  sys_name = "YDL104C"
)
```

<br>

*Add an argument to hide the figure legend*
```{r, echo = F}
plot_expr_3 <- function(input, sys_name, hide_legend = F) {
  
  gg_data <- input %>%
    filter(systematic_name == sys_name)
  
  plot_title <- gg_data$name[1]
  plot_sub <- gg_data$MF[1]
  
  res <- gg_data %>%
    ggplot(aes(rate, expression, color = nutrient)) +
    geom_point() +
    geom_smooth(method = "lm", se = F) +
    labs(title = plot_title, subtitle = plot_sub) +
    theme_cowplot()
  
  if (hide_legend) {
    res <- res +
      theme(legend.position = "none")
  }
  
  res
}
```

```{r, fig.width = 6, fig.height = 4}
plot_expr_3(
  input = brauer_gene_exp,
  sys_name = "YDL104C",
  hide_legend = T
)
```

<br>

*Use your function with `map()` to create a figure containing plots for four genes*
```{r, fig.width = 10, fig.height = 6.5, echo = F}
sys_names <- c("YNL049C", "YNL095C", "YDL104C", "YLR115W")

expr_plots <- map(
  .x = sys_names, 
  .f = plot_expr_2, 
  input = brauer_gene_exp
)

plot_grid(plotlist = expr_plots)
```

<br>

*Modify your function to take a vector of systematic_names to create the following plot*
```{r, echo = F}
plot_expr_3 <- function(input, sys_name) {
  
  input %>%
    filter(systematic_name %in% sys_name) %>%
    ggplot(aes(rate, expression, color = nutrient)) + 
    geom_point() + 
    geom_smooth(method = "lm", se = F) +
    facet_wrap(~ systematic_name) +
    theme_cowplot()
}
```

```{r, fig.width = 10, fig.height = 6.5}
name_vec <- c("YNL049C", "YNL095C", "YDL104C", "YLR115W")

plot_expr_3(
  input = brauer_gene_exp,
  sys_name = name_vec
)
```

<br>

---

<br>

## Factors

### What are factors?
Factors are useful when you want to modify how categorical data is displayed. To manipulate factors tidyverse provides the forcats package.
```{r}
# Imagine we have a character vector containing a few months
x <- c("Dec", "Apr", "Jan", "Mar")
x

# Sorting this vector will arrange the months in alphabetical order, which isn't useful
sort(x)

# To sort our months based on their order in the year, we can convert to a factor
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)

y <- factor(x, levels = month_levels)
y

sort(y)
```

<br>

---

<br>

### Using forcats with ggplot2
The forcats package has several key functions:

- `fct_relevel` to manually set factor order
- `fct_reorder` to reorder by another variable
- `fct_inorder` to order by appearance
- `fct_infreq` to order by the frequency of values
- `fct_lump` to collapse the least/most frequency values into "Other"

<br>

Lets try to use some of these functions to modify our growth rate plots.
```{r, fig.width = 6, fig.height = 4.5}
# fct_relevel
nutrient_levels <- c(
  "Phosphate", "Sulfate", "Uracil",
  "Ammonia",   "Glucose", "Leucine"
)

gg_data <- brauer_gene_exp %>%
  filter(systematic_name == "YOL066C")

gg_data %>%
  mutate(nutrient = fct_relevel(nutrient, nutrient_levels)) %>%
  
  ggplot(aes(rate, expression, color = nutrient)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = F, size = 0.5) +
  facet_wrap(~ nutrient) +
  theme_cowplot() +
  theme(legend.position = "none")

# fct_reorder
gg_data %>%
  mutate(nutrient = fct_reorder(nutrient, expression, max)) %>%
  
  ggplot(aes(rate, expression, color = nutrient)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = F, size = 0.5) +
  facet_wrap(~ nutrient) +
  theme_cowplot() +
  theme(legend.position = "none")

# fct_inorder
gg_data %>%
  mutate(nutrient = fct_inorder(nutrient)) %>%
  
  ggplot(aes(rate, expression, color = nutrient)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = F, size = 0.5) +
  facet_wrap(~ nutrient) +
  theme_cowplot() +
  theme(legend.position = "none")
```

<br>

Lets try another example using `fct_lump()` and `fct_infreq()`.
```{r, fig.width = 5, fig.height = 4.5}
gg_data <- brauer_gene_exp %>%
  select(MF, systematic_name) %>%
  unique()

# fct_lump
gg_data %>%
  mutate(MF = fct_lump(MF, n = 10)) %>%
  
  ggplot(aes(x = "MF", fill = MF)) +
  geom_bar(position = "fill") +
  theme_cowplot()

# fct_infreq
gg_data %>%
  mutate(
    MF = fct_lump(MF, n = 10),
    MF = fct_infreq(MF)
  ) %>%
  
  ggplot(aes(x = "MF", fill = MF)) +
  geom_bar(position = "fill") +
  theme_cowplot()
```

<br>

*ADD SOME EXERCISES*

```{r "EXTRAs", include = F}
# ggplot(aes(rate, expression, color = nutrient)) +
#   geom_point() +
#   geom_smooth(method = "lm", se = F, size = 0.5) +
#   theme_cowplot() +
#   theme(legend.position = "none") +
#   facet_wrap(~ nutrient)
# MF = fct_infreq(MF)
# MF = fct_reorder(MF, systematic_name, n_distinct)
# x <- brauer_gene_exp %>%
#   group_by(systematic_name) %>%
#   nest(keys = c(rate, expression)) %>%
#   mutate(slope = map(keys, ~ {
#     mod <- lm(.x$expression ~ .x$rate)
#     mod$coefficients[[2]]
#   })) %>%
#   unnest(cols = c(keys, slope))
# x %>%
#   filter(systematic_name == "YOL066C") %>%
#   ggplot(aes(rate, expression, color = nutrient)) +
#   geom_point() +
#   geom_smooth(method = "lm", se = F, size = 0.5) +
#   facet_wrap(~ fct_reorder(nutrient, slope, mean)) +
#   theme_cowplot() +
#   theme(legend.position = "none")
```








